// generated by diplomat-tool

import { Two } from "./Two.mjs"
import wasm from "./diplomat-wasm.mjs";
import * as diplomatRuntime from "./diplomat-runtime.mjs";




const One_box_destroy_registry = new FinalizationRegistry((ptr) => {
    wasm.One_destroy(ptr);
});

export class One {
    // Internal ptr reference:
    #ptr = null;

    // Lifetimes are only to keep dependencies alive.
    // Since JS won't garbage collect until there are no incoming edges.
    #selfEdge = [];
    
    #aEdge = [];
    
    
    constructor(ptr, selfEdge, aEdge) {
        
        
        this.#aEdge = aEdge;
        
        this.#ptr = ptr;
        this.#selfEdge = selfEdge;
        // Unconditionally register to destroy when this object is ready to garbage collect.
        One_box_destroy_registry.register(this, this.#ptr);
    }

    get ffiValue() {
        return this.#ptr;
    }

    // Size of our opaque type in bytes for diplomat_alloc.
    // See https://doc.rust-lang.org/reference/type-layout.html for further reference.
    static get _size() {
        return 4;
    }
    
    // Alignment of our opaque type in bytes for diplomat_alloc.
    // See https://doc.rust-lang.org/reference/type-layout.html for further reference.
    static get _align() {
        return 4;
    }


    static transitivity(hold, nohold) {
        
        const diplomat_recieve_buffer = wasm.diplomat_alloc(One._size, One._align);
        
        // This lifetime edge depends on lifetimes 'a, 'b, 'c, 'd, 'e
        let aEdges = [hold];
        const result = wasm.One_transitivity(diplomat_recieve_buffer, hold.ffiValue, nohold.ffiValue);
    
        const finalOut = new One(diplomat_recieve_buffer, [], aEdges);
        
        
        wasm.diplomat_free(diplomat_recieve_buffer, One._size, One._align);
        
    
        return finalOut;
    }

    static cycle(hold, nohold) {
        
        const diplomat_recieve_buffer = wasm.diplomat_alloc(One._size, One._align);
        
        // This lifetime edge depends on lifetimes 'a, 'b, 'c
        let aEdges = [hold];
        const result = wasm.One_cycle(diplomat_recieve_buffer, hold.ffiValue, nohold.ffiValue);
    
        const finalOut = new One(diplomat_recieve_buffer, [], aEdges);
        
        
        wasm.diplomat_free(diplomat_recieve_buffer, One._size, One._align);
        
    
        return finalOut;
    }

    static manyDependents(a, b, c, d, nohold) {
        
        const diplomat_recieve_buffer = wasm.diplomat_alloc(One._size, One._align);
        
        // This lifetime edge depends on lifetimes 'a, 'b, 'c, 'd
        let aEdges = [a, b, c, d];
        const result = wasm.One_many_dependents(diplomat_recieve_buffer, a.ffiValue, b.ffiValue, c.ffiValue, d.ffiValue, nohold.ffiValue);
    
        const finalOut = new One(diplomat_recieve_buffer, [], aEdges);
        
        
        wasm.diplomat_free(diplomat_recieve_buffer, One._size, One._align);
        
    
        return finalOut;
    }

    static returnOutlivesParam(hold, nohold) {
        
        const diplomat_recieve_buffer = wasm.diplomat_alloc(One._size, One._align);
        
        // This lifetime edge depends on lifetimes 'long
        let longEdges = [hold];
        const result = wasm.One_return_outlives_param(diplomat_recieve_buffer, hold.ffiValue, nohold.ffiValue);
    
        const finalOut = new One(diplomat_recieve_buffer, [], longEdges);
        
        
        wasm.diplomat_free(diplomat_recieve_buffer, One._size, One._align);
        
    
        return finalOut;
    }

    static diamondTop(top, left, right, bottom) {
        
        const diplomat_recieve_buffer = wasm.diplomat_alloc(One._size, One._align);
        
        // This lifetime edge depends on lifetimes 'top, 'left, 'right, 'bottom
        let topEdges = [top, left, right, bottom];
        const result = wasm.One_diamond_top(diplomat_recieve_buffer, top.ffiValue, left.ffiValue, right.ffiValue, bottom.ffiValue);
    
        const finalOut = new One(diplomat_recieve_buffer, [], topEdges);
        
        
        wasm.diplomat_free(diplomat_recieve_buffer, One._size, One._align);
        
    
        return finalOut;
    }

    static diamondLeft(top, left, right, bottom) {
        
        const diplomat_recieve_buffer = wasm.diplomat_alloc(One._size, One._align);
        
        // This lifetime edge depends on lifetimes 'left, 'bottom
        let leftEdges = [left, bottom];
        const result = wasm.One_diamond_left(diplomat_recieve_buffer, top.ffiValue, left.ffiValue, right.ffiValue, bottom.ffiValue);
    
        const finalOut = new One(diplomat_recieve_buffer, [], leftEdges);
        
        
        wasm.diplomat_free(diplomat_recieve_buffer, One._size, One._align);
        
    
        return finalOut;
    }

    static diamondRight(top, left, right, bottom) {
        
        const diplomat_recieve_buffer = wasm.diplomat_alloc(One._size, One._align);
        
        // This lifetime edge depends on lifetimes 'right, 'bottom
        let rightEdges = [right, bottom];
        const result = wasm.One_diamond_right(diplomat_recieve_buffer, top.ffiValue, left.ffiValue, right.ffiValue, bottom.ffiValue);
    
        const finalOut = new One(diplomat_recieve_buffer, [], rightEdges);
        
        
        wasm.diplomat_free(diplomat_recieve_buffer, One._size, One._align);
        
    
        return finalOut;
    }

    static diamondBottom(top, left, right, bottom) {
        
        const diplomat_recieve_buffer = wasm.diplomat_alloc(One._size, One._align);
        
        // This lifetime edge depends on lifetimes 'bottom
        let bottomEdges = [bottom];
        const result = wasm.One_diamond_bottom(diplomat_recieve_buffer, top.ffiValue, left.ffiValue, right.ffiValue, bottom.ffiValue);
    
        const finalOut = new One(diplomat_recieve_buffer, [], bottomEdges);
        
        
        wasm.diplomat_free(diplomat_recieve_buffer, One._size, One._align);
        
    
        return finalOut;
    }

    static diamondAndNestedTypes(a, b, c, d, nohold) {
        
        const diplomat_recieve_buffer = wasm.diplomat_alloc(One._size, One._align);
        
        // This lifetime edge depends on lifetimes 'a, 'b, 'c, 'd
        let aEdges = [a, b, c, d];
        const result = wasm.One_diamond_and_nested_types(diplomat_recieve_buffer, a.ffiValue, b.ffiValue, c.ffiValue, d.ffiValue, nohold.ffiValue);
    
        const finalOut = new One(diplomat_recieve_buffer, [], aEdges);
        
        
        wasm.diplomat_free(diplomat_recieve_buffer, One._size, One._align);
        
    
        return finalOut;
    }

    static implicitBounds(explicitHold, implicitHold, nohold) {
        
        const diplomat_recieve_buffer = wasm.diplomat_alloc(One._size, One._align);
        
        // This lifetime edge depends on lifetimes 'a, 'b, 'c, 'd, 'x
        let aEdges = [explicitHold, implicitHold];
        const result = wasm.One_implicit_bounds(diplomat_recieve_buffer, explicitHold.ffiValue, implicitHold.ffiValue, nohold.ffiValue);
    
        const finalOut = new One(diplomat_recieve_buffer, [], aEdges);
        
        
        wasm.diplomat_free(diplomat_recieve_buffer, One._size, One._align);
        
    
        return finalOut;
    }

    static implicitBoundsDeep(explicit, implicit1, implicit2, nohold) {
        
        const diplomat_recieve_buffer = wasm.diplomat_alloc(One._size, One._align);
        
        // This lifetime edge depends on lifetimes 'a, 'b, 'c, 'd
        let aEdges = [explicit, implicit1, implicit2];
        const result = wasm.One_implicit_bounds_deep(diplomat_recieve_buffer, explicit.ffiValue, implicit1.ffiValue, implicit2.ffiValue, nohold.ffiValue);
    
        const finalOut = new One(diplomat_recieve_buffer, [], aEdges);
        
        
        wasm.diplomat_free(diplomat_recieve_buffer, One._size, One._align);
        
    
        return finalOut;
    }

    

}