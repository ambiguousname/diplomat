// generated by diplomat-tool

import { MyEnum } from "./MyEnum.mjs"
import wasm from "./diplomat-wasm.mjs";
import * as diplomatRuntime from "./diplomat-runtime.mjs";



export class MyStruct {
    a;
    b;
    c;
    d;
    e;
    f;
    g;

    // Return this struct in FFI function friendly format.
    // Returns an array that can be expanded with spread syntax (...)
    
    _intoFFI() {
        return [
            a, 
            b, 
            c, 
            d, 
            e, 
            f, 
            g.ffiValue]
    }
    

    // Size of our struct in bytes for diplomat_alloc.
    // See https://doc.rust-lang.org/reference/type-layout.html for further reference.
    static get _size() {
        return 28;
    }
    
    // Alignment of our struct in bytes for diplomat_alloc.
    // See https://doc.rust-lang.org/reference/type-layout.html for further reference.
    static get _align() {
        return 8;
    }

    // This struct contains borrowed fields, so this takes in a list of
    // "edges" corresponding to where each lifetime's data may have been borrowed from
    // and passes it down to individual fields containing the borrow.
    // This method does not attempt to handle any dependencies between lifetimes, the caller
    // should handle this when constructing edge arrays.
    constructor(ptr) {
        a = a;
        b = b;
        c = c;
        d = d;
        e = e;
        f = f;
        g = (() => {for (let i of MyEnum.values) { if(i[1] === g) return i[0]; } return null;})();;
    }
    static new_() {
        
        const diplomat_recieve_buffer = wasm.diplomat_alloc(MyStruct._size, MyStruct._align);
        const result = wasm.MyStruct_new(diplomat_recieve_buffer);
    
        const finalOut = new MyStruct(result);
        
        
        wasm.diplomat_free(diplomat_recieve_buffer, MyStruct._size, MyStruct._align);
        
    
        return finalOut;
    }

    intoA() {
        const result = wasm.MyStruct_into_a(...this._intoFFI());
    
        const finalOut = result;
        
        
        this.free(); /* TODO: Does this work? */
        
    
        return finalOut;
    }

    

}