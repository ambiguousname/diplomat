{%- if let Some(it) = iterator %}

next() {% if typescript %}: IteratorResult<{{it}}>;{% else %}{
    const out = this.#iteratorNext();

    return {
        value: out,
        done: out === null,
    };
}{% endif %}
{% endif -%}

{%- if let Some(ctor) = constructor %}
constructor(
    {%- for param in ctor.parameters -%}
    {{- param.name -}}
    {%- if typescript %}: {{ param.ty -}}{%- endif -%}
    {%- if !loop.last -%}, {% endif -%}
    {%- endfor -%}
) {%- if !typescript %} {
    {#- Quick and dirty way to access an exposed constructor if we don't want to provide the internalConstructor
    symbol to our constructor (for instance, if we are a struct that only takes structObj as a parameter for the constructor) #}
    if (arguments[0] === diplomatRuntime.exposeConstructor) {
        return this.#internalConstructor(...Array.prototype.slice.call(arguments, 1));
    } else if (arguments[0] === diplomatRuntime.internalConstructor) { 
        {#-
        If the first symbol is an internal constructor symbol, that means we can't possibly be looking for the internal
        #defaultConstructor. So instead we just pass along all of the arguments to the internalConstructor.
        #}
        return this.#internalConstructor(...arguments);
    } else {
        return this.#defaultConstructor(...arguments);
    }
} {%- else %}; {%- endif %}
{% endif -%}